"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * @format
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.reactNativeWindowsInit = exports.windowsInitOptions = void 0;
const yargs_1 = __importDefault(require("yargs"));
const fs_1 = __importDefault(require("@react-native-windows/fs"));
const semver_1 = __importDefault(require("semver"));
const child_process_1 = require("child_process");
const valid_url_1 = __importDefault(require("valid-url"));
const prompts_1 = __importDefault(require("prompts"));
const find_up_1 = __importDefault(require("find-up"));
const chalk_1 = __importDefault(require("chalk"));
const npm_registry_fetch_1 = __importDefault(require("npm-registry-fetch"));
const telemetry_1 = require("@react-native-windows/telemetry");
/**
 * Important:
 * Do not use process.exit() in this script as it will prevent telemetry from being sent.
 * See https://github.com/microsoft/ApplicationInsights-node.js/issues/580
 */
const requireGenerateWindows_1 = __importDefault(require("./requireGenerateWindows"));
let NPM_REGISTRY_URL = 'https://registry.npmjs.org';
try {
    const npmConfReg = (0, child_process_1.execSync)('npm config get registry').toString().trim();
    if (valid_url_1.default.isUri(npmConfReg)) {
        NPM_REGISTRY_URL = npmConfReg;
    }
}
catch (error) {
    // Ignore workspace errors as `npm config` does not support it
    const stderr = ((_a = error === null || error === void 0 ? void 0 : error.stderr) === null || _a === void 0 ? void 0 : _a.toString()) || '';
    if (!stderr.includes('ENOWORKSPACES')) {
        throw error;
    }
}
// Causes the type-checker to ensure the options object is a valid yargs options object
function initOptions(options) {
    return options;
}
exports.windowsInitOptions = initOptions({
    version: {
        type: 'string',
        describe: 'The version of react-native-windows to use.',
    },
    namespace: {
        type: 'string',
        describe: "The native project namespace. This should be expressed using dots as separators. i.e. 'Level1.Level2.Level3'. The generator will apply the correct syntax for the target language",
    },
    verbose: {
        type: 'boolean',
        describe: 'Enables logging.',
        default: false,
    },
    telemetry: {
        type: 'boolean',
        describe: 'Controls sending telemetry that allows analysis of usage and failures of the react-native-windows CLI',
        default: true,
    },
    language: {
        type: 'string',
        describe: 'The language the project is written in.',
        choices: ['cs', 'cpp'],
        default: 'cpp',
    },
    overwrite: {
        type: 'boolean',
        describe: 'Overwrite any existing files without prompting',
        default: false,
    },
    projectType: {
        type: 'string',
        describe: 'The type of project to initialize (supported on 0.64+)',
        choices: ['app', 'lib'],
        default: 'app',
    },
    experimentalNuGetDependency: {
        type: 'boolean',
        describe: '[Experimental] change to start consuming a NuGet containing a pre-built dll version of Microsoft.ReactNative',
        hidden: true,
        default: false,
    },
    useHermes: {
        type: 'boolean',
        describe: '[Experimental] Use Hermes instead of Chakra as the JS engine (supported on 0.64+ for C++ projects)',
        default: false,
    },
    useWinUI3: {
        type: 'boolean',
        describe: '[Experimental] Use WinUI 3 (Windows App SDK)',
        hidden: true,
        default: false,
    },
    nuGetTestVersion: {
        type: 'string',
        describe: '[internalTesting] By default the NuGet version matches the rnw package. This flag allows manually specifying the version for internal testing.',
        hidden: true,
    },
    nuGetTestFeed: {
        type: 'string',
        describe: '[internalTesting] Allows a test feed to be added to the generated NuGet configuration',
        hidden: true,
    },
    useDevMode: {
        type: 'boolean',
        describe: '[internalTesting] Link rather than Add/Install the react-native-windows package. This option is for the development workflow of the developers working on react-native-windows.',
        hidden: true,
        default: undefined,
        conflicts: 'version',
    },
});
const yargsParser = yargs_1.default
    .version(false)
    .options(exports.windowsInitOptions)
    .strict(true);
function getReactNativeProjectName() {
    console.log('Reading project name from package.json...');
    const cwd = process.cwd();
    const pkgJsonPath = find_up_1.default.sync('package.json', { cwd });
    if (!pkgJsonPath) {
        throw new telemetry_1.CodedError('NoPackageJson', 'Unable to find package.json.  This should be run from within an existing react-native project.');
    }
    let name = fs_1.default.readJsonFileSync(pkgJsonPath).name;
    if (!name) {
        const appJsonPath = find_up_1.default.sync('app.json', { cwd });
        if (appJsonPath) {
            console.log('Reading project name from app.json...');
            name = fs_1.default.readJsonFileSync(pkgJsonPath).name;
        }
    }
    if (!name) {
        console.error('Please specify name in package.json or app.json');
    }
    return name;
}
function getReactNativeVersion() {
    console.log('Reading react-native version from node_modules...');
    const rnPkgJsonPath = require.resolve('react-native/package.json', {
        paths: [process.cwd()],
    });
    if (fs_1.default.existsSync(rnPkgJsonPath)) {
        return require(rnPkgJsonPath).version;
    }
    throw new telemetry_1.CodedError('NoReactNativeFound', 'Must be run from a project that already depends on react-native, and has react-native installed.');
}
function getDefaultReactNativeWindowsSemVerForReactNativeVersion(rnVersion) {
    const validVersion = semver_1.default.valid(rnVersion);
    if (validVersion) {
        const major = semver_1.default.major(validVersion);
        const minor = semver_1.default.minor(validVersion);
        if (major === 0 && minor >= 59) {
            return `^${major}.${minor}.0-0`;
        }
    }
    throw new telemetry_1.CodedError('UnsupportedReactNativeVersion', `Error: Unsupported version of react-native: ${chalk_1.default.cyan(rnVersion)} react-native-windows supports react-native versions ${chalk_1.default.cyan('>=0.60')}`);
}
function getMatchingReactNativeSemVerForReactNativeWindowsVersion(rnwVersion) {
    const validVersion = semver_1.default.valid(rnwVersion);
    if (validVersion) {
        const major = semver_1.default.major(validVersion);
        const minor = semver_1.default.minor(validVersion);
        if (major === 0 && minor >= 59) {
            return `^${major}.${minor}`;
        }
    }
    return 'unknown';
}
async function getLatestMatchingVersion(pkg, versionSemVer) {
    const npmResponse = await npm_registry_fetch_1.default.json(pkg, { registry: NPM_REGISTRY_URL });
    // Check if versionSemVer is a tag (i.e. 'canary', 'latest', 'preview', etc.)
    if ('dist-tags' in npmResponse) {
        const distTags = npmResponse['dist-tags'];
        if (versionSemVer in distTags) {
            return distTags[versionSemVer];
        }
    }
    // Check if versionSemVer is a semver version (i.e. '^0.60.0-0', '0.63.1', etc.)
    if ('versions' in npmResponse) {
        const versions = Object.keys(npmResponse.versions);
        if (versions.length > 0) {
            const candidates = versions
                .filter(v => semver_1.default.satisfies(v, versionSemVer))
                .sort(semver_1.default.rcompare);
            if (candidates.length > 0) {
                return candidates[0];
            }
        }
    }
    throw new telemetry_1.CodedError('NoMatchingPackageVersion', `No matching version of ${pkg}@${versionSemVer} found`);
}
async function getLatestRNWVersion() {
    const rnwLatestVersion = await getLatestMatchingRNWVersion('latest');
    if (!rnwLatestVersion) {
        throw new telemetry_1.CodedError('NoLatestReactNativeWindows', 'Error: No version of react-native-windows@latest found');
    }
    return rnwLatestVersion;
}
async function getLatestMatchingRNWVersion(versionSemVer) {
    try {
        const version = await getLatestMatchingVersion('react-native-windows', versionSemVer);
        return version;
    }
    catch (err) {
        return null;
    }
}
function installReactNativeWindows(version, verbose, useDevMode) {
    const cwd = process.cwd();
    const execOptions = verbose ? { stdio: 'inherit' } : {};
    if (useDevMode) {
        const packageCmd = isProjectUsingYarn(cwd) ? 'yarn' : 'npm';
        (0, child_process_1.execSync)(`${packageCmd} link react-native-windows`, execOptions);
        version = '*';
    }
    else if (!version) {
        throw new telemetry_1.CodedError('Unknown', 'Unexpected error encountered. If you are able, please file an issue on: https://github.com/microsoft/react-native-windows/issues/new/choose');
    }
    console.log(`Installing ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(version)}...`);
    const pkgJsonPath = find_up_1.default.sync('package.json', { cwd });
    if (!pkgJsonPath) {
        throw new telemetry_1.CodedError('NoPackageJson', 'Unable to find package.json');
    }
    const pkgJson = require(pkgJsonPath);
    // check how react-native is installed
    if ('dependencies' in pkgJson && 'react-native' in pkgJson.dependencies) {
        // regular dependency (probably an app), inject into json and run install
        pkgJson.dependencies['react-native-windows'] = version;
        fs_1.default.writeFileSync(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
        (0, child_process_1.execSync)(isProjectUsingYarn(cwd) ? 'yarn' : 'npm install', execOptions);
    }
    else if ('devDependencies' in pkgJson &&
        'react-native' in pkgJson.devDependencies) {
        // only a dev dependency (probably a native module),
        (0, child_process_1.execSync)(isProjectUsingYarn(cwd)
            ? `yarn add react-native-windows@${version} --dev`
            : `npm install react-native-windows@${version} --save-dev`, execOptions);
    }
    else {
        throw new telemetry_1.CodedError('NoReactNativeDependencies', "Unable to find 'react-native' in package.json's dependencies or devDependencies. This should be run from within an existing react-native app or lib.");
    }
    console.log(chalk_1.default.green(`react-native-windows@${chalk_1.default.cyan(require(require.resolve('react-native-windows/package.json', {
        paths: [cwd],
    })).version)} successfully installed.`));
}
/**
 * Sanitizes the given option for telemetry.
 * @param key The key of the option.
 * @param value The unsanitized value of the option.
 * @returns The sanitized value of the option.
 */
function optionSanitizer(key, value) {
    // Do not add a default case here.
    // Strings risking PII should just return true if present, false otherwise.
    // All others should return the value (or false if undefined).
    switch (key) {
        case 'namespace':
        case 'nuGetTestFeed':
        case 'nuGetTestVersion':
            return value ? true : false;
        case 'verbose':
        case 'version':
        case 'telemetry':
        case 'language':
        case 'overwrite':
        case 'projectType':
        case 'experimentalNuGetDependency':
        case 'useHermes':
        case 'useWinUI3':
        case 'useDevMode':
            return value === undefined ? false : value;
    }
}
/**
 * Sets up and starts the telemetry gathering for the CLI command.
 * @param args The raw CLI args.
 * @param options The CLI args parsed by yargs.
 */
async function startTelemetrySession(args, options) {
    const verbose = options.verbose === true;
    if (!options.telemetry) {
        if (verbose) {
            console.log('Telemetry is disabled');
        }
        return;
    }
    if (verbose) {
        console.log(`Running ${(0, telemetry_1.nodeArchitecture)()} node on a ${(0, telemetry_1.deviceArchitecture)()} machine`);
    }
    if ((0, telemetry_1.deviceArchitecture)() !== (0, telemetry_1.nodeArchitecture)()) {
        console.warn('This version of node was built for a different architecture than this machine and may cause unintended behavior');
    }
    // Setup telemetry, but don't get NPM package version info right away as
    // we're going to change things and this may interfere with the resolver
    await telemetry_1.Telemetry.setup({ populateNpmPackageVersions: false });
    const sanitizedOptions = (0, telemetry_1.yargsOptionsToOptions)(options, optionSanitizer);
    const sanitizedDefaultOptions = (0, telemetry_1.yargsOptionsToOptions)(yargsParser.parse(''), optionSanitizer);
    const sanitizedArgs = (0, telemetry_1.optionsToArgs)(sanitizedOptions, args);
    const startInfo = {
        commandName: 'react-native-windows-init',
        args: sanitizedArgs,
        options: sanitizedOptions,
        defaultOptions: sanitizedDefaultOptions,
    };
    telemetry_1.Telemetry.startCommand(startInfo);
}
/**
 * Adds the new project's telemetry info by calling and processing `react-native config`.
 */
async function addProjectInfoToTelemetry() {
    if (!telemetry_1.Telemetry.isEnabled()) {
        return;
    }
    try {
        const config = JSON.parse((0, child_process_1.execSync)('npx react-native config', {
            stdio: ['ignore', 'pipe', 'ignore'],
        }).toString());
        const projectInfo = await (0, telemetry_1.configToProjectInfo)(config);
        if (projectInfo) {
            telemetry_1.Telemetry.setProjectInfo(projectInfo);
        }
        const projectFile = (0, telemetry_1.getProjectFileFromConfig)(config);
        if (projectFile) {
            await telemetry_1.Telemetry.populateNuGetPackageVersions(projectFile);
        }
    }
    catch (_a) { }
}
/**
 * Ends the gathering of telemetry for the CLI command.
 * @param error The error (if any) thrown during the command.
 */
function endTelemetrySession(error) {
    const endInfo = {
        resultCode: 'Success',
    };
    if (error) {
        endInfo.resultCode =
            error instanceof telemetry_1.CodedError ? error.type : 'Unknown';
    }
    telemetry_1.Telemetry.endCommand(endInfo);
}
/**
 * Sets the process exit code and offers some information at the end of a CLI command.
 * @param loggingIsEnabled Is verbose logging enabled.
 * @param error The error caught during the process, if any.
 */
function setExitProcessWithError(loggingIsEnabled, error) {
    if (error) {
        const errorType = error instanceof telemetry_1.CodedError ? error.type : 'Unknown';
        process.exitCode = telemetry_1.CodedErrors[errorType];
        if (loggingIsEnabled) {
            console.log(`Command failed with error ${chalk_1.default.bold(errorType)}: ${error.message}`);
            if (telemetry_1.Telemetry.isEnabled()) {
                console.log(`Your telemetry sessionId was ${chalk_1.default.bold(telemetry_1.Telemetry.getSessionId())}`);
            }
        }
        else {
            console.log(`Command failed. Re-run the command with ${chalk_1.default.bold('--verbose')} for more information.`);
        }
    }
}
/**
 * Check if project is using Yarn (has `yarn.lock` in the tree)
 */
function isProjectUsingYarn(cwd) {
    return !!find_up_1.default.sync('yarn.lock', { cwd });
}
async function reactNativeWindowsInit(args) {
    args = args !== null && args !== void 0 ? args : process.argv;
    const options = yargsParser.parse(args);
    if (options.verbose) {
        console.log(options);
    }
    await startTelemetrySession(args, options);
    let initWindowsError;
    try {
        const name = getReactNativeProjectName();
        const ns = options.namespace || name;
        const useDevMode = !!options.useDevMode; // TS assumes the type is undefined
        let version = options.version;
        if (options.useWinUI3 && options.experimentalNuGetDependency) {
            throw new telemetry_1.CodedError('IncompatibleOptions', "Error: Incompatible options specified. Options '--useWinUI3' and '--experimentalNuGetDependency' are incompatible", { detail: 'useWinUI3 and experimentalNuGetDependency' });
        }
        if (!useDevMode) {
            if (!version) {
                const rnVersion = getReactNativeVersion();
                version =
                    getDefaultReactNativeWindowsSemVerForReactNativeVersion(rnVersion);
            }
            const rnwResolvedVersion = await getLatestMatchingRNWVersion(version);
            if (!rnwResolvedVersion) {
                if (options.version) {
                    console.warn(`Warning: Querying npm to find react-native-windows@${options.version} failed.  Attempting to continue anyway...`);
                }
                else {
                    const rnwLatestVersion = await getLatestRNWVersion();
                    throw new telemetry_1.CodedError('NoAutoMatchingReactNativeWindows', `
  No compatible version of ${chalk_1.default.green('react-native-windows')} found.
  The latest supported version is ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(rnwLatestVersion)}.
  Please modify your application to use ${chalk_1.default.green('react-native')}@${chalk_1.default.cyan(getMatchingReactNativeSemVerForReactNativeWindowsVersion(rnwLatestVersion))} or another supported version of ${chalk_1.default.green('react-native')} and try again.
  `, { rnwLatestVersion: rnwLatestVersion });
                }
            }
            if (!options.version) {
                console.log(`Latest matching version of ${chalk_1.default.bold('react-native-windows')} for ${chalk_1.default.green('react-native')}@${chalk_1.default.cyan(getReactNativeVersion())} is ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(rnwResolvedVersion)}`);
                if (rnwResolvedVersion && semver_1.default.prerelease(rnwResolvedVersion)) {
                    const rnwLatestVersion = await getLatestRNWVersion();
                    console.warn(`
  ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(rnwResolvedVersion)} is a ${chalk_1.default.yellow('pre-release')} version.
  The latest supported version is ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(rnwLatestVersion)}.
  You can either downgrade your version of ${chalk_1.default.green('react-native')} to ${chalk_1.default.cyan(getMatchingReactNativeSemVerForReactNativeWindowsVersion(rnwLatestVersion))}, or continue with a ${chalk_1.default.yellow('pre-release')} version of ${chalk_1.default.bold('react-native-windows')}.
  `);
                    const confirm = (await (0, prompts_1.default)({
                        type: 'confirm',
                        name: 'confirm',
                        message: `Do you wish to continue with ${chalk_1.default.green('react-native-windows')}@${chalk_1.default.cyan(rnwResolvedVersion)}?`,
                    })).confirm;
                    if (!confirm) {
                        throw new telemetry_1.CodedError('UserCancel', 'User canceled');
                    }
                }
            }
            if (rnwResolvedVersion) {
                version = rnwResolvedVersion;
            }
        }
        installReactNativeWindows(version, options.verbose, useDevMode);
        const generateWindows = (0, requireGenerateWindows_1.default)();
        // Now that new NPM packages have been installed, get their versions
        await telemetry_1.Telemetry.populateNpmPackageVersions();
        await generateWindows(process.cwd(), name, ns, {
            language: options.language,
            overwrite: options.overwrite,
            verbose: options.verbose,
            projectType: options.projectType,
            experimentalNuGetDependency: options.experimentalNuGetDependency,
            useWinUI3: options.useWinUI3,
            useHermes: options.useHermes,
            useDevMode: useDevMode,
            nuGetTestVersion: options.nuGetTestVersion,
            nuGetTestFeed: options.nuGetTestFeed,
            telemetry: options.telemetry,
        });
        // Now that the project has been generated, add project info
        await addProjectInfoToTelemetry();
    }
    catch (ex) {
        // Since we may have failed before generating a project, make
        // sure we get those NPM package versions
        await telemetry_1.Telemetry.populateNpmPackageVersions();
        initWindowsError =
            ex instanceof Error ? ex : new Error(String(ex));
        telemetry_1.Telemetry.trackException(initWindowsError);
        console.error(chalk_1.default.red(initWindowsError.message));
        console.error(initWindowsError);
    }
    endTelemetrySession(initWindowsError);
    setExitProcessWithError(options.verbose, initWindowsError);
}
exports.reactNativeWindowsInit = reactNativeWindowsInit;
//# sourceMappingURL=Cli.js.map